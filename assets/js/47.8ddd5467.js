(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{450:function(e,s,t){"use strict";t.r(s);var r=t(45),v=Object(r.a)({},(function(){var e=this,s=e.$createElement,t=e._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"promisea-规范"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promisea-规范"}},[e._v("#")]),e._v(" promiseA+ 规范")]),e._v(" "),t("p",[e._v("Promise 是异步编程的一种解决方案，是为了解决回调地狱问题，将回调函数的嵌套改为链式调用")]),e._v(" "),t("h2",{attrs:{id:"promisea-规范描述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promisea-规范描述"}},[e._v("#")]),e._v(" PromiseA+规范描述")]),e._v(" "),t("h3",{attrs:{id:"_1-术语"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-术语"}},[e._v("#")]),e._v(" 1.术语")]),e._v(" "),t("ol",[t("li",[e._v("promise 是一个有 then 方法的对象或者函数，行为遵循 PromiseA+规范")]),e._v(" "),t("li",[e._v("thenable 是一个有 then 方法的对象或者函数")]),e._v(" "),t("li",[e._v("value 是 promise 状态成功的值，也就是 resolve 的参数，包括各种数据类型")]),e._v(" "),t("li",[e._v("reason 是 promise 状态失败时的值，也就是 reject 的参数，表示拒绝的原因")]),e._v(" "),t("li",[e._v("exception 是一个使用 throw 抛出的异常值")])]),e._v(" "),t("h3",{attrs:{id:"规范"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#规范"}},[e._v("#")]),e._v(" 规范")]),e._v(" "),t("h4",{attrs:{id:"promise-states"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-states"}},[e._v("#")]),e._v(" Promise States")]),e._v(" "),t("p",[e._v("promise 应该有三种状态. 要注意他们之间的流转关系.")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("pending")]),e._v(" "),t("p",[e._v("1.1 初始的状态, 可改变.")]),e._v(" "),t("p",[e._v("1.2 一个 promise 在 resolve 或者 reject 前都处于这个状态。")]),e._v(" "),t("p",[e._v("1.3 可以通过 resolve -> fulfilled 状态;")]),e._v(" "),t("p",[e._v("1.4 可以通过 reject -> rejected 状态;")])]),e._v(" "),t("li",[t("p",[e._v("fulfilled")]),e._v(" "),t("p",[e._v("2.1 最终态, 不可变.")]),e._v(" "),t("p",[e._v("2.2 一个 promise 被 resolve 后会变成这个状态.")]),e._v(" "),t("p",[e._v("2.3 必须拥有一个 value 值")])]),e._v(" "),t("li",[t("p",[e._v("rejected")]),e._v(" "),t("p",[e._v("3.1 最终态, 不可变.")]),e._v(" "),t("p",[e._v("3.2 一个 promise 被 reject 后会变成这个状态")]),e._v(" "),t("p",[e._v("3.3 必须拥有一个 reason")])])]),e._v(" "),t("p",[e._v("Tips: 总结一下, 就是 promise 的状态流转是这样的")]),e._v(" "),t("p",[e._v("pending -> resolve(value) -> fulfilled\npending -> reject(reason) -> rejected")]),e._v(" "),t("h3",{attrs:{id:"then"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#then"}},[e._v("#")]),e._v(" then")]),e._v(" "),t("p",[e._v("promise 应该提供一个 then 方法, 用来访问最终的结果, 无论是 value 还是 reason.")]),e._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[e._v("promise"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("then")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("onFulfilled"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" onRejected"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),t("ol",[t("li",[t("p",[e._v("参数要求")]),e._v(" "),t("p",[e._v("1.1 onFulfilled 必须是函数类型, 如果不是函数, 应该被忽略.")]),e._v(" "),t("p",[e._v("1.2 onRejected 必须是函数类型, 如果不是函数, 应该被忽略.")])]),e._v(" "),t("li",[t("p",[e._v("onFulfilled 特性")]),e._v(" "),t("p",[e._v("2.1 在 promise 变成 fulfilled 时，应该调用 onFulfilled, 参数是 value")]),e._v(" "),t("p",[e._v("2.2 在 promise 变成 fulfilled 之前, 不应该被调用.")]),e._v(" "),t("p",[e._v("2.3 只能被调用一次(所以在实现的时候需要一个变量来限制执行次数)")])]),e._v(" "),t("li",[t("p",[e._v("onRejected 特性")]),e._v(" "),t("p",[e._v("3.1 在 promise 变成 rejected 时，应该调用 onRejected, 参数是 reason")]),e._v(" "),t("p",[e._v("3.2 在 promise 变成 rejected 之前, 不应该被调用.")]),e._v(" "),t("p",[e._v("3.3 只能被调用一次(所以在实现的时候需要一个变量来限制执行次数)")])]),e._v(" "),t("li",[t("p",[e._v("onFulfilled 和 onRejected 应该是微任务")]),e._v(" "),t("p",[e._v("这里用 queueMicrotask 来实现微任务的调用.")])]),e._v(" "),t("li",[t("p",[e._v("then 方法可以被调用多次")]),e._v(" "),t("p",[e._v("5.1 promise 状态变成 fulfilled 后，所有的 onFulfilled 回调都需要按照 then 的顺序执行, 也就是按照注册顺序执行(所以在实现的时候需要一个数组来存放多个 onFulfilled 的回调)")]),e._v(" "),t("p",[e._v("5.2 promise 状态变成 rejected 后，所有的 onRejected 回调都需要按照 then 的顺序执行, 也就是按照注册顺序执行(所以在实现的时候需要一个数组来存放多个 onRejected 的回调)")])]),e._v(" "),t("li",[t("p",[e._v("返回值")]),e._v(" "),t("p",[e._v("then 应该返回一个 promise")]),e._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[e._v("promise2 "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" promise1"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("then")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("onFulfilled"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" onRejected"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),t("p",[e._v("6.1 onFulfilled 或 onRejected 执行的结果为 x, 调用 resolvePromise( 这里大家可能难以理解, 可以先保留疑问, 下面详细讲一下 resolvePromise 是什么东西 )")]),e._v(" "),t("p",[e._v("6.2 如果 onFulfilled 或者 onRejected 执行时抛出异常 e, promise2 需要被 reject")]),e._v(" "),t("p",[e._v("6.3 如果 onFulfilled 不是一个函数, promise2 以 promise1 的 value 触发 fulfilled")]),e._v(" "),t("p",[e._v("6.4 如果 onRejected 不是一个函数, promise2 以 promise1 的 reason 触发 rejected")])]),e._v(" "),t("li",[t("p",[e._v("resolvePromise")]),e._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[e._v("resolvePromise")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("promise2"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" x"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" resolve"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" reject"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),t("p",[e._v("7.1 如果 promise2 和 x 相等，那么 reject TypeError")]),e._v(" "),t("p",[e._v("7.2 如果 x 是一个 promsie")]),e._v(" "),t("p",[e._v("如果 x 是 pending 态，那么 promise 必须要在 pending,直到 x 变成 fulfilled or rejected.")]),e._v(" "),t("p",[e._v("如果 x 被 fulfilled, fulfill promise with the same value.")]),e._v(" "),t("p",[e._v("如果 x 被 rejected, reject promise with the same reason.")]),e._v(" "),t("p",[e._v("7.3 如果 x 是一个 object 或者 是一个 function")]),e._v(" "),t("p",[e._v("let then = x.then.")]),e._v(" "),t("p",[e._v("如果 x.then 这步出错，那么 reject promise with e as the reason.")]),e._v(" "),t("p",[e._v("如果 then 是一个函数，then.call(x, resolvePromiseFn, rejectPromise)")]),e._v(" "),t("p",[e._v("resolvePromiseFn 的 入参是 y, 执行 resolvePromise(promise2, y, resolve, reject);")]),e._v(" "),t("p",[e._v("rejectPromise 的 入参是 r, reject promise with r.")]),e._v(" "),t("p",[e._v("如果 resolvePromise 和 rejectPromise 都调用了，那么第一个调用优先，后面的调用忽略。")]),e._v(" "),t("p",[e._v("如果调用 then 抛出异常 e")]),e._v(" "),t("p",[e._v("如果 resolvePromise 或 rejectPromise 已经被调用，那么忽略")]),e._v(" "),t("p",[e._v("则，reject promise with e as the reason")]),e._v(" "),t("p",[e._v("如果 then 不是一个 function. fulfill promise with x.")])])])])}),[],!1,null,null,null);s.default=v.exports}}]);